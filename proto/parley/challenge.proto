syntax = "proto3";

package parley.v1;

import "proof.proto";

// === Challenge / PKCE flow for verifier-api ===

enum CodeChallengeMethod {
  CODE_CHALLENGE_METHOD_UNSPECIFIED = 0;
  S256 = 1;
}

// Start a verification challenge (RP -> verifier).
message StartChallengeRequest {
  string origin              = 1; // RP origin or app-id
  uint32 cutoff_days         = 2; // required threshold
  string code_challenge      = 3; // base64url(no padding) of SHA-256(code_verifier)
  CodeChallengeMethod method = 4; // must be S256
}

// Verifier -> RP & Wallet: challenge material
message StartChallengeResponse {
  string challenge_id           = 1;
  bytes  rp_challenge           = 2; // 32 bytes: binding to RP (origin, nonce, etc.)
  uint32 cutoff_days            = 3;
  uint32 verifying_key_id       = 4;
  // absolute expiry is an HTTP concern; proto stays minimal
}

// Wallet -> Verifier: present proof for a challenge.
message SubmitProofRequest {
  string  challenge_id = 1;
  // The AgeProof embeds rp_challenge and cutoff_days; verifier checks they match this challenge.
  AgeProof proof       = 2;
  // If you implement PKCE strictly, include the code_verifier here:
  string  code_verifier = 3;
}

// RP -> Verifier: poll challenge status
message PollChallengeRequest {
  string challenge_id = 1;
}

message PollChallengeResponse {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    PENDING = 1;
    VERIFIED = 2;
    FAILED = 3;
    EXPIRED = 4;
  }
  Status status = 1;
}